# 解析

完成网络请求和响应，如果响应头中`Content-Type`的值是`text/html`，就代表是请求的是页面，就需要`解析`和`渲染`了，解析部分主要分为3个步骤：
- 构建`DOM`树
- `样式`计算
- 生成`布局树(Layout Tree)`

## 构建DOM树

由于浏览器无法理解`HTML字符串`，因此将一系列的字节流转换为一种有意义并且方便操作的数据结构，即`DOM树`。`DOM树`本质上是一个以`document`为根节点的多叉树。

### 上下文无关法

个人理解：即后续的操作与前面的操作没有关系，不会影响

在HTML中如果扫描到`form`标签，**上下文无法**的处理方式是直接创建对应form的DOM对象；而真实的HTML5场景中，解析器会查看`form`的上下文，如果这个`form`的父标签也是`form`，那么就直接跳过当前的`form`标签，否则才创建DOM对象。

### 解析算法

1. 标记化---词法分析
2. 建树---语法分析

#### 标记化算法

标记算法输入为`HTML文本`，输出为`HTML标记`，也成为**标记生成器**。其中运用**有限自动状态机**来完成。即在当前状态下，接收一个或多个字符，就会更新到下一个状态

```html
<html>
    <body>
        Hello Rain
    </body>
</html>
```

- 标记化过程

1. 遇到`<`，状态为**标记打开**
2. 接收`[a-z]`的字符，会进入**标记名称状态**
3. 这个状态一直保持，直到遇到`>`，表示标记名称记录完成，这时候变为**数据状态**。后续遇到`body`标签做同样的处理。在`<body>`中的`>`，进入**数据状态**，之后保持这样状态接收后面的字符hello Rain。
4. 接收到`</body>`中的`<`，回到**标记打开**，接收下一个`/`后，这个时候会创建一个`end tag`的token。
5. 进入**标记名称状态**，遇到`>`回到**数据状态**。后面就以相同的方式处理。

#### 建树算法

DON树是一个以`document`为根节点的多叉树，因此解析器首先会创建一个`document`对象，标记生成器会把每个标记的信息发送给**建树器**，**建树器**接收到相应的标记时，会**创建对应的DOM对象**。创建这个`DOM`对象后做两件事情：
1. 将`DOM对象`加入到DOM树中。
2. 将对应标记压入存放开发（与`闭合标签`意思对应）元素的栈中。

- 建树过程

1. 首先为**初始化状态**
2. 接收到标记生成器传来的`html`标签，这时状态变为**before html状态**。同时创建一个`HTMLHtmlElement`的DOM元素，将其加到`document`根对象上，并进行压栈操作。
3. 接收到状态自动变为**before head**，此时从标记生成器那边传来`body`，表示并没有`head`，这时候**建树器**会自动创建一个`HTMLHeadElement`并将其加入到`DOM树`中。
4. 由于没有head，就进入到**in head状态**，直接跳到**after head**
5. 现在**标记生成器**传来了`body`标记，创建`HTMLBodyElement`,插入到DOM树中，同时压入开放标记栈中。
6. 接着进入**in body**，然后来接收后面一系列的字符：hello Rain。接收到第一个字符的时候，会创建一个Text节点并把字符插入其中，然后把Text节点插入到DOM树的下面。随着不断接收后面的字符，这些字符会附在Text节点上。
7. **标记生成器**传过来一个body的结束标记，进入到**after body**状态
8. **标记生成器**最后传过来一个`html`的结束标记，进入到**after body**的状态，表示解析过程到此结束。

#### 容错机制

1. 使用`</br>`而不是`<br>`
```javaScript
if (t->isCloseTag(barTag) && m_document->inCompatMode()) {
    reportError(MalformBRError)
    t->beginTag = true
}
// 会将</br>全部替换为<br>
```

2. 表格离散

```html
<table>
    <table>
        <tr><td>inner table</td></tr>
    </table>
    <tr><td>outer table</td></tr>
</table>
```

Webkit 会自动转换为

```html
<table>
    <tr><td>inner table</td></tr>
</table>
<table>
    <tr><td>outer table</td></tr>
</table>
```

3. 表单元素嵌套，嵌套时直接忽略里面的`form`

## 样式计算

css样式三种来源：
1. link标签引用
2. style标签中的样式
3. 元素的内嵌style属性
### 格式化样式表

- 浏览器无法识别CSS样式文本，因此渲染引擎接收到CSS文本之后第一件事情就是将其转化为一个结构化的对象，即styleSheets
- 在浏览器控制台能够通过`document.styleSheets`来查看这个最终的结构。这个结构包含了三种css来源，为后面的样式操作提供了基础。

### 标准化样式属性

一些CSS样式的数值并不容易被渲染引擎所理解，因此需要在计算样式之前将他们标准化。如`em`->`px`，`red`->`#ff0000`,`bold`->`700`等。

### 计算每个节点的具体样式

在`格式化`和`标准化`样式之后，接下来就可以计算每个节点的具体样式信息了

主要用到的是**继承**和**层叠**

1. 继承： 每个子节点都会继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫`UserAgent`样式。这就是继承规则。
2. 层叠：CSS的最大特点就是层叠性。
- 计算完样式之后，所有的样式值会被挂载到`window.computedStyle`中，可以通过JS来获取计算后的样式。

## 生成布局树

已经生成`DOM树`和`DOM样式`，接下来要做的就是通过浏览器的布局系统`确定元素的位置`，也就是生成一颗`布局树`

1. 遍历生成的DOM树节点，并把他们添加到`布局树`中
2. 计算布局树节点的坐标位置

- 注意：布局树包含可见元素，对于`head`标签和设置了`display: none`的元素，将不会被放入其中。